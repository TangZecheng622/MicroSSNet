#'  脆弱性计算
#'  @param cor 输入相关性网络
#'  @export
Vulnerability <- function(
    cor){
  cor1 <- cor
  diag(cor1)<-0
  cor1[abs(cor1)>0]<-1
  g = graph_from_adjacency_matrix(as.matrix(cor1), mode="undirected", weighted = NULL, diag = FALSE, add.colnames = NULL)

  #移除孤立节点
  iso_node_id = which(degree(g)==0)
  g2 = delete.vertices(g, iso_node_id)
  length(V(g2));length(E(g2))
  network.efficiency <- function(graph){
    if(is_igraph(graph)==F) warning("Please use a valid iGraph object")
    dd <- 1/distances(graph)
    diag(dd) <- NA
    efficiency <- mean(dd, na.rm=T)
    #denom <- nrow(dd)*(ncol(dd)-1)
    #sum(dd, na.rm=T)/denom
    return(efficiency)
  }

  info.centrality.vertex <- function(graph, net=NULL, verbose=F){
    if(is_igraph(graph)==F) warning("Please use a valid iGraph object")
    if(is.null(net)) net <- network.efficiency(graph)
    if(is.numeric(net)==F){
      warning("Please ensure net is a scalar numeric")
      net <- network.efficiency(graph)
    }
    count <- c()
    for(i in 1:length(V(graph))){
      count <- c(count, (net-network.efficiency(delete.vertices(graph, i)))/net)
      if(verbose){
        print(paste("node",i,"current\ info\ score", count[i], collapse="\t"))
      }
    }
    return(count)
  }
  #计算每个节点的漏洞
  node.vul<-info.centrality.vertex(g2)
  #计算出该网络的最大节点易损性
  max(node.vul)

}
